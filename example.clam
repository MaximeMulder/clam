type Fun = (Void, Void) -> Void;
type Tuple = (Void, Void);
type Recorda = {a: Void, b: Void};
type Union = Void | Void;
type Inter = Void & Void;
type Abs = [T, U] Void;
type App = Abs[Void, Void];

type Self = [T: Any] T;
type Universal = [T: Any] -> T;

type PairO = (IntOrString, IntOrString);
type IntOrString = Int | String;

type A = [T: Any] -> B;
type B = Int;
type C = B;

def name = string;
def void_ = void;
def true_ = true;
def false_ = false;
def int = 0;
def char = 'a';
def string = "Hello world !";
def preop = +2;
def binop = 0 + 1;
def ascr = name : String;
def block = { type AAAA = Int; def a = b; def b = c; def c = name; 0 : AAAA };
def if_ = if true then name else name;
def abs = (a: String, b: String) -> Tuple => @(void, void);
def app = abs(name, name);
def type_abs: [AA: Tuple, C: Tuple] -> Tuple = [AA: Tuple, C: Tuple] => { @(void, void): AA };
def type_app = type_abs[Tuple, Tuple];
def a: (Int) -> Int = (b: Int) => b + a(b);

type AB = [T] T;

def ab: AB[Bool] = true;

type Pair = [T] (T, T);

def pair: Pair[Bool] = @(true, false);

type Record = [T] { a: T, b: T };

def record: Record[Bool | Int] = @{ a = true, b = 0 };

def aaa = {
    type AI = [T: Bool] T;
    type BI = AI[Bool];
    0
};
























def increment = (i: Int) => i + 123;

def main = increment(5);
